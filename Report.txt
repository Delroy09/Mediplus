MEDI+ PATIENT MANAGEMENT SYSTEM
DATABASE DESIGN REPORT - CA-1
Submitted by: Delroy Pires & Nash D’souza
Roll No: 20, 04
Class: FY MSC IT
Subject: Advanced Database Management Systems
Date: January 31, 2026

CERTIFICATE OF DECLARATION
We, Delroy Pires and Nash Dsouza, declare that this project on "Medi+ Patient Management System - Database Design" is our original work completed for CA-2 evaluation. All sources have been acknowledged.
Signature: _______________
Date: January 31, 2026

INDEX
Section
Page
1. Requirement Gathering


2. Conceptual Design (E-R Diagram)


3. Logical Design (Schemas & Constraints)


4. Schema Refinement (Normalization)


5. Conclusion


6. Future Scope


7. Bibliography






1. REQUIREMENT GATHERING
1.1 Problem Statement
Healthcare facilities often struggle with manual patient record-keeping, leading to data inconsistency and errors. There is often a lack of secure access controls for sensitive medical data, and no audit trail exists for patient status changes (e.g., Admitted → Surgery → Discharged). Furthermore, patients cannot easily view their assigned doctor, appointments, or medical history due to inefficient manual tracking.
1.2 Proposed Solution
The Medi+ Patient Management System addresses these issues by implementing a secure, role-based digital system using Laravel 12.0 (Backend), MySQL 8.0 (Database), and Bootstrap 5.3.8 (Frontend).
Security: IT-admin approval for all accounts (no public sign-up for doctors).
Roles: Distinct dashboards for Admin, Doctor, and Patient.
Audit: Maintains a complete audit trail for all status changes.
Access: Ensures patients and doctors have real-time access to relevant information.
1.3 User Roles
Admin: Approves/rejects account requests, creates user accounts, assigns doctors to patients. Cannot modify medical records.
Doctor: Views assigned patients, updates patient status, creates medical records for assigned patients only.
Patient: Views personal details, assigned doctor, appointments, and medical history. Can edit only mobile number and address.
1.4 Data Requirements
The system requires storage for the following entities: Users, Patients, Doctors, Account Requests, Patient-Doctor Assignments, Medical Records, Appointments, and Patient Status Logs. The system must also support Deletion Requests, allowing discharged patients to request account deletion, which is subject to admin approval and audit.

2. CONCEPTUAL DESIGN
2.1 Entity-Relationship Diagram

{Diagram Here}

2.2 Entities and Relationships Description
User–Patient/Doctor (1:1): One user account is linked to exactly one Patient or Doctor profile via a specific Foreign Key.
Patient–Doctor Assignment (M:N): Patients are assigned to Doctors via a junction table (patient_doctor_assignments), allowing history tracking of previous doctors.
Patient–Medical Records (1:N): One patient has many medical records over time.
Doctor–Medical Records (1:N): One doctor creates many medical records.
Patient–Status Logs (1:N): One patient generates multiple status log entries (Audit Trail).
Patient–Deletion Requests (1:N): One patient can submit multiple deletion requests (typically only one pending at a time), each reviewed by an admin user.
Admin (User)–Deletion Requests (1:N): One admin user can review and approve or reject many deletion requests.

3. LOGICAL DESIGN (RELATIONAL SCHEMAS)
3.1 Table Schemas
1. USERS


USERS(id, name, email UNIQUE, password, role, created_at, updated_at)
PK: id
Check: role IN ('admin', 'doctor', 'patient')


2. PATIENTS


PATIENTS(id, user_id, mobile, blood_group, dob, gender, address, status, admission_date)
PK: id
FK: user_id → USERS(id) [Unique, On Delete Cascade]
Check: blood_group IN ('A+', 'O+', etc.)


3. DOCTORS


DOCTORS(id, user_id, specialization, department, license_no UNIQUE, years_of_experience)
PK: id
FK: user_id → USERS(id) [Unique, On Delete Cascade]


4. ACCOUNT_REQUESTS


ACCOUNT_REQUESTS(id, name, email, mobile, status, requested_role, reviewed_by)
PK: id
FK: reviewed_by → USERS(id)
Check: status IN ('pending', 'approved', 'rejected')


5. PATIENT_DOCTOR_ASSIGNMENTS


PATIENT_DOCTOR_ASSIGNMENTS(id, patient_id, doctor_id, assigned_date, is_active)
PK: id
FK: patient_id → PATIENTS(id)
FK: doctor_id → DOCTORS(id)
Unique: (patient_id, doctor_id) WHERE is_active=TRUE


6. MEDICAL_RECORDS


MEDICAL_RECORDS(id, patient_id, doctor_id, visit_date, diagnosis, treatment, notes)
PK: id
FK: patient_id → PATIENTS(id)
FK: doctor_id → DOCTORS(id)


7. APPOINTMENTS


APPOINTMENTS(id, patient_id, doctor_id, appointment_date, status, type)
PK: id
FK: patient_id → PATIENTS(id)
FK: doctor_id → DOCTORS(id)


8. PATIENT_STATUS_LOGS


PATIENT_STATUS_LOGS(id, patient_id, old_status, new_status, changed_by, changed_at)
PK: id
FK: patient_id → PATIENTS(id)
FK: changed_by → USERS(id)

9. DELETION_REQUESTS



DELETION_REQUESTS(id, patient_id, reason, status, reviewed_by, deleted_at, created_at, updated_at)
PK: id
FK: patient_id → PATIENTS(id)
FK: reviewed_by → USERS(id)
Check: status IN ('pending', 'approved', 'rejected')



4. SCHEMA REFINEMENT (NORMALIZATION)
4.1 First Normal Form (1NF)
Definition: Eliminate repeating groups and ensure atomicity.
Violation (Before):
The PATIENTS table originally contained a medical_history column storing comma-separated values (e.g., "Diabetes diagnosed 2024, Flu 2025"). This violated 1NF as the attribute was not atomic.
Correction (After):
We removed the medical_history column and created a separate MEDICAL_RECORDS table. Now, each diagnosis is a single row in the new table.
PATIENTS(id, name, ...)
MEDICAL_RECORDS(id, patient_id, diagnosis, ...)
4.2 Second Normal Form (2NF)
Definition: Eliminate partial dependencies.
All tables in the system use a single-column Primary Key (id). Therefore, no non-key attribute can depend on only "part" of the key. All tables automatically satisfy 2NF.
4.3 Third Normal Form (3NF)
Definition: Eliminate transitive dependencies.
All non-key attributes depend only on the primary key. For example, in the PATIENTS table, user_id is a foreign key, but the User's name and email are correctly stored in the USERS table, not repeated in PATIENTS.
4.4 Boyce-Codd Normal Form (BCNF)
Since all tables are in 3NF and every determinant is a candidate key (the id or unique foreign keys), the design satisfies BCNF.

5. CONCLUSION
The Medi+ Patient Management System database design successfully organizes complex hospital data into 8 normalized tables. By separating User credentials from Profile data and isolating Medical Records, the system ensures data integrity, security, and scalability. The design is fully normalized to BCNF, preventing redundancy and update anomalies. Additionally the design also supports secure, auditable patient account deletion requests, ensuring compliance with privacy requirements and maintaining data integrity.

6. FUTURE SCOPE
Database Enhancements:
Triggers:
Auto-notification on status change (email/SMS alerts).
Update last_visited_date on medical record insert.
Deactivate assignments on patient discharge.
Views:
active_patients_view – Admitted/Surgery patients with assigned doctors.
doctor_workload_view – Patient count, upcoming appointments per doctor.
pending_approvals_view – Account requests waiting for IT review.
Stored Procedures:
discharge_patient(patient_id, discharge_notes) – Complete discharge process.
generate_monthly_report(month, year) – Statistics aggregation.
Feature Additions:
Prescription management module with medication tracking.
Lab results integration (blood tests, X-rays).
Billing and insurance claims.
Mobile app with push notifications for appointment reminders.
Telemedicine video consultation integration.
Security Enhancements:
Two-factor authentication (2FA).
Encrypted medical records at rest.
Session timeout and activity logging.
Password reset via email verification.

7. BIBLIOGRAPHY
Laravel Documentation (v12.x) - Database Migrations.
MySQL 8.0 Reference Manual - Constraints and Data Types.
Elmasri & Navathe - "Fundamentals of Database Systems" (Normalization).
Bootstrap 5.3.8 Documentation - UI Components.


